# -*- coding: utf-8 -*-
"""food-delivery-data-analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kkYudmKZWgSDEIFVZED23-jKS6Bzuhb4

### **Project Title:**

**Food Delivery Efficiency Analysis**

### **Objective:**

To analyze food delivery performance data and identify key factors influencing delivery efficiency and customer satisfaction.

### **Data Description:**

The dataset contains delivery-related attributes such as delivery person details, vehicle condition, customer ratings, restaurant and delivery coordinates, and delivery time.

**Key Columns:**

* `Delivery_person_Age`: Age of the delivery person.
* `Delivery_person_Ratings`: Average rating received by the delivery person.
* `Restaurant_latitude`, `Restaurant_longitude`: Restaurant location.
* `Delivery_location_latitude`, `Delivery_location_longitude`: Customer location.
* `Vehicle_condition`: Condition rating of the delivery vehicle (0–3).
* `multiple_deliveries`: Number of deliveries made in a single trip.
* `Time taken (mins)`: Total time taken to complete the delivery.

### **Analysis Approach:**

1. Data cleaning and preprocessing.
2. Compute delivery distance using geospatial coordinates.
3. Perform exploratory data analysis (EDA) to identify relationships affecting efficiency.
4. Correlation and regression analysis to determine key predictors of delivery time.
5. Summarize insights and propose strategies for improvement.

### **Tools and Libraries:**

Python, Pandas, NumPy, Matplotlib, Seaborn, Scikit-learn (optional for modeling).

### **Expected Outcomes:**

* Insights on how age, ratings, distance, and vehicle condition affect delivery time.
* Identification of patterns to optimize route planning and delivery scheduling.
* Data-driven recommendations for operational improvements.
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from geopy.distance import geodesic

# Load dataset
df = pd.read_csv("food_delivery3.txt", delimiter="\t")



# Basic cleaning (optional)
df = df.dropna(subset=["Time taken (mins)", "Delivery_person_Age", "Delivery_person_Ratings"])

# Preview
df.head()

df.columns

"""## Delivery Time Analysis"""

# 1. Average delivery time by delivery person age
age_time = df.groupby("Delivery_person_Age")["Time taken (mins)"].mean()
plt.figure()
age_time.plot(kind="line")
plt.title("Average Delivery Time by Age")
plt.xlabel("Delivery Person Age")
plt.ylabel("Average Time (mins)")
plt.show()

# 2. Correlation between delivery time and vehicle condition
plt.figure()
sns.boxplot(x="Vehicle_condition", y="Time taken (mins)", data=df)
plt.title("Delivery Time vs Vehicle Condition")
plt.show()

corr_vc = df["Vehicle_condition"].corr(df["Time taken (mins)"])
print(f"Correlation between vehicle condition and delivery time: {corr_vc:.2f}")

# 3. Impact of multiple deliveries
plt.figure()
sns.boxplot(x="multiple_deliveries", y="Time taken (mins)", data=df)
plt.title("Impact of Multiple Deliveries on Delivery Time")
plt.show()

# 4. Outlier detection
plt.figure()
sns.boxplot(y=df["Time taken (mins)"])
plt.title("Outlier Detection in Delivery Time")
plt.show()

# Identify extreme outliers
Q1 = df["Time taken (mins)"].quantile(0.25)
Q3 = df["Time taken (mins)"].quantile(0.75)
IQR = Q3 - Q1
outliers = df[df["Time taken (mins)"] > Q3 + 1.5 * IQR]
print(f"Number of outliers: {len(outliers)}")

"""## Location / Geographic insight"""

# Compute distance using latitude and longitude
def calc_distance(row):
    rest = (row["Restaurant_latitude"], row["Restaurant_longitude"])
    dest = (row["Delivery_location_latitude"], row["Delivery_location_longitude"])
    return geodesic(rest, dest).km

df["Distance_km"] = df.apply(calc_distance, axis=1)

# 1. Delivery time vs distance
plt.figure()
sns.scatterplot(x="Distance_km", y="Time taken (mins)", data=df, alpha=0.5)
plt.title("Delivery Time vs Distance")
plt.xlabel("Distance (km)")
plt.ylabel("Time (mins)")
plt.show()

# Correlation
corr_dist = df["Distance_km"].corr(df["Time taken (mins)"])
print(f"Correlation between distance and time: {corr_dist:.2f}")

# 2. Identify high-delay zones
delay_zones = df.groupby(["Delivery_location_latitude", "Delivery_location_longitude"])["Time taken (mins)"].mean().reset_index()
top_delay_zones = delay_zones.sort_values("Time taken (mins)", ascending=False).head(10)
print("Top high-delay zones:")
print(top_delay_zones)



"""## Delivery Worker Performance"""

# 1. Ratings vs delivery time
plt.figure()
sns.scatterplot(x="Delivery_person_Ratings", y="Time taken (mins)", data=df, alpha=0.5)
plt.title("Ratings vs Delivery Time")
plt.xlabel("Ratings")
plt.ylabel("Time (mins)")
plt.show()

corr_rate = df["Delivery_person_Ratings"].corr(df["Time taken (mins)"])
print(f"Correlation between ratings and time: {corr_rate:.2f}")

# 2. Segment delivery personnel by rating range
df["Rating_Group"] = pd.cut(df["Delivery_person_Ratings"], bins=[0, 3, 4, 4.5, 5], labels=["Low", "Average", "Good", "Excellent"])
rating_group_stats = df.groupby("Rating_Group")[["Time taken (mins)", "multiple_deliveries"]].mean()
print(rating_group_stats)
rating_group_stats.plot(kind="bar", subplots=True, layout=(1, 2), figsize=(10,4))
plt.suptitle("Performance by Rating Group")
plt.show()

"""## Operations analysis"""

# 1. Vehicle condition trend
vehicle_stats = df.groupby("Vehicle_condition")[["Time taken (mins)", "Delivery_person_Ratings"]].mean()
print(vehicle_stats)

plt.figure()
vehicle_stats["Time taken (mins)"].plot(kind="bar")
plt.title("Average Delivery Time by Vehicle Condition")
plt.show()

# 2. Multi-delivery efficiency
multi_stats = df.groupby("multiple_deliveries")[["Time taken (mins)", "Delivery_person_Ratings"]].mean()
print(multi_stats)

plt.figure()
multi_stats["Time taken (mins)"].plot(kind="bar")
plt.title("Average Delivery Time by Number of Deliveries")
plt.show()

# 3. Age vs multiple deliveries
plt.figure()
sns.boxplot(x="multiple_deliveries", y="Delivery_person_Age", data=df)
plt.title("Age vs Multiple Deliveries")
plt.show()

"""##



--


## Correlations

"""

# Select numeric features for correlation
numeric_cols = ["Delivery_person_Age", "Delivery_person_Ratings", "Vehicle_condition",
                "multiple_deliveries", "Distance_km", "Time taken (mins)"]

plt.figure(figsize=(8,6))
sns.heatmap(df[numeric_cols].corr(), annot=True, cmap="coolwarm", fmt=".2f")
plt.title("Correlation Heatmap")
plt.show()


"""

correlation heatmap for feature relationships and a regression analysis to identify which factors most influence delivery time.


What to Look For:

Strong positive correlations (close to +1) suggest features that increase delivery time.

Strong negative correlations (close to -1) suggest features that reduce delivery time.
"""

"""## Regression Analysis"""

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score, mean_absolute_error

# Prepare features (X) and target (y)
features = ["Delivery_person_Age", "Delivery_person_Ratings", "Vehicle_condition",
            "multiple_deliveries", "Distance_km"]

df1 = df.dropna()
X = df1[features]
y = df1["Time taken (mins)"]

# Split data
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Train model
model = LinearRegression()
model.fit(X_train, y_train)

# Predictions
y_pred = model.predict(X_test)

# Evaluation metrics
r2 = r2_score(y_test, y_pred)
mae = mean_absolute_error(y_test, y_pred)
print(f"R² Score: {r2:.3f}")
print(f"Mean Absolute Error: {mae:.2f} minutes")

# Coefficients (feature importance)
coefficients = pd.DataFrame({
    "Feature": features,
    "Coefficient": model.coef_
}).sort_values(by="Coefficient", ascending=False)
print(coefficients)

plt.figure(figsize=(8,5))
sns.barplot(x="Coefficient", y="Feature", data=coefficients)
plt.title("Feature Importance (Linear Regression)")
plt.show()